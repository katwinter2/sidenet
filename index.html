<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>surfing sidenet</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 -960 960 960'%3E%3Cpath fill='%23d4a0b0' d='M80-40v-80h40q32 0 62-10t58-30q28 20 58 29.5t62 9.5q32 0 62.5-9.5T480-160q28 20 58 29.5t62 9.5q32 0 62.5-9.5T720-160q27 20 57.5 30t62.5 10h40v80h-40q-31 0-61-7.5T720-70q-29 15-59 22.5T600-40q-31 0-61-7.5T480-70q-29 15-59 22.5T360-40q-31 0-61-7.5T240-70q-29 15-59 22.5T120-40H80Zm260-760 222 41q14 2 27 11t22 25l35 62q26 45 72 73t102 28v80q-78 0-142-39T577-621l-90 61 153 120v154q16 11 31 23t29 23q-21 18-46 29t-54 11q-36 0-67-17t-53-43q-22 26-53 43t-67 17q-10 0-19.5-1.5T322-206q-86-59-144-119t-58-104q0-31 24-41t50-10q29 0 67 8.5t81 24.5l-21-124q-4-20 4.5-39.5T352-642l86-58q-3 0-14.5-2.5t-25.5-5-25.5-5Q361-715 358-715l-113 77-45-66 140-96Zm72 284 18 106q27 13 67 34.5t63 35.5v-60L412-516Zm268-224q-33 0-56.5-23.5T600-820q0-33 23.5-56.5T680-900q33 0 56.5 23.5T760-820q0 33-23.5 56.5T680-740Z'/%3E%3C/svg%3E" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Condensed&display=swap" rel="stylesheet">
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-storage-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
  :root {
    --bg: #1a1a1a;
    --surface: #242428;
    --surface2: #2c2c32;
    --border: #3a3a42;
    --text: #f0f0f2;
    --text-dim: #9090a0;
    --accent: #f0c8d8;
    --accent-glow: #f0c8d840;
    --accent-hover: #f5a0c0;
    --danger: #ff4466;
    --green: #44dd88;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Ubuntu Condensed', 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Top toolbar */
  .toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .nav-buttons {
    display: flex;
    gap: 4px;
  }

  .nav-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 32px;
    height: 32px;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.15s;
  }

  .nav-btn:hover:not(:disabled) {
    background: var(--surface);
    color: var(--text);
    border-color: var(--accent);
  }

  .nav-btn:disabled {
    opacity: 0.3;
    cursor: default;
  }

  .address-bar {
    flex: 1;
    display: flex;
    align-items: center;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0 12px;
    height: 36px;
    transition: border-color 0.15s;
  }

  .address-bar:focus-within {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .address-prefix {
    color: var(--text-dim);
    font-size: 13px;
    margin-right: 4px;
    user-select: none;
  }

  .address-input {
    flex: 1;
    background: none;
    border: none;
    color: var(--text);
    font-size: 14px;
    outline: none;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  }

  .address-input::placeholder { color: var(--text-dim); }

  .go-btn {
    background: var(--accent);
    border: none;
    color: #1a1a1a;
    height: 36px;
    padding: 0 16px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
    transition: all 0.15s;
    white-space: nowrap;
  }

  .go-btn:hover { background: var(--accent-hover); }
  .go-btn:disabled { opacity: 0.5; cursor: default; }

  /* Model selector & settings */
  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .model-select {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    outline: none;
    max-width: 280px;
  }

  .model-select:focus { border-color: var(--accent); }

  .settings-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 32px;
    height: 32px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }

  .settings-btn:hover {
    color: var(--text);
    border-color: var(--accent);
  }

  /* Main content row: content + feed sidebar */
  .main-row {
    flex: 1;
    display: flex;
    flex-direction: row;
    overflow: hidden;
    min-height: 0;
  }

  /* Main content area */
  .content-area {
    flex: 1;
    overflow-y: auto;
    padding: 0;
    min-width: 0;
    transition: flex 0.3s ease;
  }

  .page-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 32px 24px;
  }

  /* Generated page styling */
  .generated-page {
    line-height: 1.7;
    font-size: 15px;
  }

  .generated-page h1 {
    font-size: 28px;
    margin-bottom: 16px;
    color: var(--text);
    border-bottom: 1px solid var(--border);
    padding-bottom: 12px;
  }

  .generated-page h2 {
    font-size: 22px;
    margin: 24px 0 12px;
    color: var(--text);
  }

  .generated-page h3 {
    font-size: 18px;
    margin: 20px 0 8px;
    color: var(--text);
  }

  .generated-page p {
    margin-bottom: 14px;
    color: var(--text);
    opacity: 0.9;
  }

  .generated-page a {
    color: var(--accent);
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: all 0.15s;
    cursor: pointer;
  }

  .generated-page a:hover {
    color: var(--accent-hover);
    border-bottom-color: var(--accent-hover);
  }

  .generated-page ul, .generated-page ol {
    margin: 0 0 14px 24px;
  }

  .generated-page li { margin-bottom: 6px; }

  .generated-page blockquote {
    border-left: 3px solid var(--accent);
    padding: 8px 16px;
    margin: 14px 0;
    background: var(--surface);
    border-radius: 0 6px 6px 0;
    color: var(--text-dim);
  }

  .generated-page code {
    background: var(--surface2);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 13px;
  }

  .generated-page pre {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    overflow-x: auto;
    margin: 14px 0;
  }

  .generated-page pre code {
    background: none;
    padding: 0;
  }

  .generated-page img, .page-image {
    max-width: 100%;
    border-radius: 8px;
    margin: 16px 0;
    border: 1px solid var(--border);
  }

  .generated-page table {
    width: 100%;
    border-collapse: collapse;
    margin: 14px 0;
  }

  .generated-page th, .generated-page td {
    border: 1px solid var(--border);
    padding: 8px 12px;
    text-align: left;
  }

  .generated-page th {
    background: var(--surface2);
    font-weight: 600;
  }

  .generated-page hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 24px 0;
  }

  /* Loading state */
  .loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 60vh;
    gap: 20px;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    color: var(--text-dim);
    font-size: 14px;
    text-align: center;
  }

  .loading-step {
    color: var(--accent);
    font-size: 13px;
    margin-top: 4px;
  }

  /* Welcome screen */
  .welcome-header {
    text-align: center;
    padding: 32px 0 24px;
  }

  .welcome-logo {
    font-size: 42px;
    font-weight: 800;
    background: linear-gradient(135deg, var(--accent), #e8a0b8);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }

  .welcome-sub {
    color: var(--text-dim);
    font-size: 15px;
    max-width: 440px;
    line-height: 1.6;
    margin: 0 auto;
  }

  /* Welcome feed section */
  .welcome-feed-section {
    margin-top: 24px;
    border-top: 1px solid var(--border);
    padding-top: 20px;
  }

  .welcome-feed-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 16px;
  }

  .welcome-feed-header h3 {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
  }

  .welcome-feed-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 12px;
  }

  .welcome-feed-list .feed-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 16px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .welcome-feed-list .feed-card:hover {
    border-color: var(--accent);
    background: var(--surface2);
    transform: translateY(-1px);
  }

  /* Settings modal */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
  }

  .modal-overlay.open { display: flex; }

  .modal {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    width: 420px;
    max-width: 90vw;
  }

  .modal h2 {
    font-size: 18px;
    margin-bottom: 20px;
  }

  .form-group {
    margin-bottom: 16px;
  }

  .form-group label {
    display: block;
    font-size: 13px;
    color: var(--text-dim);
    margin-bottom: 6px;
  }

  .form-group input {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .form-group input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .tonal-modifier-display {
    margin-top: 6px;
    font-size: 11px;
    color: var(--text-dim);
    font-style: italic;
  }
  .tonal-modifier-label {
    color: var(--accent);
    margin-right: 4px;
  }

  .form-hint {
    font-size: 11px;
    color: var(--text-dim);
    margin-top: 4px;
  }

  .modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 20px;
  }

  .btn-secondary {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
  }

  .btn-primary {
    background: var(--accent);
    border: none;
    color: #1a1a1a;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
  }

  .btn-primary:hover { background: var(--accent-hover); }

  .btn-danger {
    background: transparent;
    border: 1px solid var(--danger);
    color: var(--danger);
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.15s;
  }

  .btn-danger:hover {
    background: var(--danger);
    color: white;
  }

  .btn-danger:disabled {
    opacity: 0.4;
    pointer-events: none;
  }

  /* Temperature slider */
  .temperature-control {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .temperature-control input[type="range"] {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }

  .temperature-control input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
  }

  .temperature-control input[type="range"]::-webkit-slider-thumb:hover {
    background: var(--accent-hover);
  }

  .temperature-value {
    font-family: 'SF Mono', 'Fira Code', monospace;
    font-size: 13px;
    color: var(--text);
    min-width: 32px;
    text-align: right;
  }

  /* Prompt preset row */
  .prompt-preset-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .prompt-preset-row select {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    outline: none;
    font-family: inherit;
  }

  .prompt-preset-row select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .btn-icon {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 34px;
    height: 34px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .btn-icon:hover {
    color: var(--text);
    border-color: var(--accent);
  }

  /* Prompt editor modal */
  .prompt-editor-overlay { z-index: 101; }

  .modal.prompt-editor-modal {
    width: 600px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
  }

  .prompt-editor-modal textarea {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 6px;
    font-size: 13px;
    font-family: 'SF Mono', 'Fira Code', monospace;
    line-height: 1.5;
    resize: vertical;
    min-height: 200px;
    max-height: 400px;
    outline: none;
  }

  .prompt-editor-modal textarea:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent-glow);
  }

  .prompt-editor-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 16px;
    gap: 8px;
    flex-wrap: wrap;
  }

  .prompt-editor-actions .left-actions,
  .prompt-editor-actions .right-actions {
    display: flex;
    gap: 8px;
  }

  /* Error state */
  .error-banner {
    background: #ff446620;
    border: 1px solid var(--danger);
    color: var(--danger);
    padding: 12px 16px;
    border-radius: 8px;
    margin: 16px 0;
    font-size: 14px;
  }

  /* Image placeholder during loading */
  .image-placeholder {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 40px;
    text-align: center;
    color: var(--text-dim);
    margin: 16px 0;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* Scrollbar */
  .content-area::-webkit-scrollbar { width: 8px; }
  .content-area::-webkit-scrollbar-track { background: var(--bg); }
  .content-area::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
  }
  .content-area::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

  /* Connection indicator dot */
  .settings-btn-wrapper {
    position: relative;
    display: inline-flex;
  }

  .connection-dot {
    position: absolute;
    top: -2px;
    right: -2px;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--danger);
    border: 2px solid var(--surface);
    z-index: 1;
  }

  .connection-dot.connected { background: var(--green); }

  .connection-dot-tooltip {
    display: none;
    position: absolute;
    bottom: calc(100% + 8px);
    right: 0;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 200;
    pointer-events: none;
  }

  .settings-btn-wrapper:hover .connection-dot:not(.connected) ~ .connection-dot-tooltip {
    display: block;
  }

  /* Exploration scrubber */
  .scrubber-bar {
    position: relative;
    height: 6px;
    margin-top: 10px;
    background: var(--border);
    border-radius: 3px;
    cursor: pointer;
  }
  .scrubber-bar::before {
    content: '';
    position: absolute;
    left: 0; right: 0;
    top: -10px; bottom: -10px;
    z-index: 1;
  }

  .scrubber-fill {
    position: absolute; top: 0; left: 0; height: 100%;
    background: var(--accent); border-radius: 3px;
    width: 0; transition: width 0.1s ease; pointer-events: none;
  }

  .scrubber-dot {
    position: absolute; top: 50%;
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--accent); border: 1.5px solid var(--surface);
    transform: translate(-50%, -50%);
    transition: transform 0.15s ease, background 0.15s ease, width 0.15s ease, height 0.15s ease;
    pointer-events: none; z-index: 2;
  }
  .scrubber-dot.root { width: 10px; height: 10px; background: var(--accent-hover); }
  .scrubber-bar:hover .scrubber-dot { width: 12px; height: 12px; }
  .scrubber-bar:hover .scrubber-dot.root { width: 14px; height: 14px; }
  .scrubber-dot.active {
    transform: translate(-50%, -50%) scale(1.4);
    background: var(--accent-hover);
    box-shadow: 0 0 8px var(--accent-glow);
  }

  .scrubber-popup {
    position: absolute; bottom: calc(100% + 10px); left: 0;
    transform: translateX(-50%);
    background: var(--surface); border: 1px solid var(--border);
    border-radius: 8px; padding: 8px 12px;
    min-width: 160px; max-width: 280px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    pointer-events: none; opacity: 0;
    transition: opacity 0.15s ease; z-index: 10; font-size: 12px;
  }
  .scrubber-popup.visible { opacity: 1; }
  .scrubber-popup::after {
    content: ''; position: absolute; top: 100%; left: 50%;
    transform: translateX(-50%);
    border: 5px solid transparent; border-top-color: var(--border);
  }

  .scrubber-popup-title { font-weight: 600; color: var(--text); margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .scrubber-popup-url { font-size: 10px; color: var(--accent); font-family: 'SF Mono', 'Fira Code', monospace; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .scrubber-popup-concepts { display: flex; flex-wrap: wrap; gap: 4px; }
  .scrubber-concept-tag { background: var(--bg); color: var(--text-dim); padding: 2px 6px; border-radius: 4px; font-size: 10px; max-width: 140px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .scrubber-popup-diff { margin-top: 4px; font-size: 10px; color: var(--text-dim); }
  .scrubber-popup-diff .diff-count { color: var(--green); font-weight: 500; }
  .scrubber-popup-thumb { margin-bottom: 6px; border-radius: 4px; overflow: hidden; background: var(--bg); }
  .scrubber-popup-thumb img { width: 100%; height: auto; max-height: 120px; object-fit: cover; display: block; border-radius: 4px; }

  /* History panel */
  .history-panel {
    position: fixed;
    top: 0;
    right: -380px;
    width: 380px;
    height: 100vh;
    background: var(--surface);
    border-left: 1px solid var(--border);
    z-index: 90;
    display: flex;
    flex-direction: column;
    transition: right 0.25s ease;
  }

  .history-panel.open { right: 0; }

  .history-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .history-header h3 {
    font-size: 15px;
    font-weight: 600;
  }

  .history-header-actions {
    display: flex;
    gap: 6px;
  }

  .history-header-actions button {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 4px 10px;
    border-radius: 5px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .history-header-actions button:hover {
    color: var(--text);
    border-color: var(--accent);
  }

  .history-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
  }

  .history-list::-webkit-scrollbar { width: 6px; }
  .history-list::-webkit-scrollbar-track { background: transparent; }
  .history-list::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 3px;
  }

  .history-empty {
    text-align: center;
    color: var(--text-dim);
    padding: 40px 16px;
    font-size: 13px;
  }

  .history-date-group {
    padding: 8px 16px 4px;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .history-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 10px 16px;
    cursor: pointer;
    transition: background 0.1s;
    border-bottom: 1px solid var(--border);
  }

  .history-item:hover { background: var(--surface2); }

  .history-item-content {
    flex: 1;
    min-width: 0;
  }

  .history-item-title {
    font-size: 13px;
    font-weight: 500;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .history-item-url {
    font-size: 11px;
    color: var(--text-dim);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-top: 2px;
    font-family: 'SF Mono', 'Fira Code', monospace;
  }

  .history-item-time {
    font-size: 11px;
    color: var(--text-dim);
    white-space: nowrap;
    flex-shrink: 0;
    margin-top: 2px;
  }

  .history-item-delete {
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-size: 14px;
    padding: 0 2px;
    opacity: 0;
    transition: opacity 0.1s;
    flex-shrink: 0;
  }

  .history-item:hover .history-item-delete { opacity: 1; }
  .history-item-delete:hover { color: var(--danger); }

  .history-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.3);
    z-index: 89;
    display: none;
  }

  .history-backdrop.open { display: block; }

  /* Feed panel (inline sidebar, right side) */
  .feed-panel {
    width: 0;
    min-width: 0;
    overflow: hidden;
    background: var(--surface);
    border-left: 0 solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: width 0.3s ease, min-width 0.3s ease, border-left-width 0.3s ease;
  }

  .feed-panel.open {
    width: 380px;
    min-width: 380px;
    border-left-width: 1px;
  }

  .feed-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }

  .feed-header h3 { font-size: 15px; font-weight: 600; }

  .feed-header-actions {
    display: flex;
    gap: 6px;
  }

  .feed-header-actions button {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 4px 10px;
    border-radius: 5px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .feed-header-actions button:hover {
    color: var(--text);
    border-color: var(--accent);
  }

  .feed-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px 0;
  }

  .feed-list::-webkit-scrollbar { width: 6px; }
  .feed-list::-webkit-scrollbar-track { background: transparent; }
  .feed-list::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .feed-empty {
    text-align: center;
    color: var(--text-dim);
    padding: 40px 16px;
    font-size: 13px;
    line-height: 1.6;
  }

  .feed-card {
    padding: 14px 16px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
    transition: background 0.1s;
  }

  .feed-card:hover { background: var(--surface2); }

  .feed-card-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .feed-card-url {
    font-size: 11px;
    color: var(--accent);
    font-family: 'SF Mono', 'Fira Code', monospace;
    margin-bottom: 6px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .feed-card-preview {
    font-size: 12px;
    color: var(--text-dim);
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    margin-bottom: 8px;
  }

  .feed-card-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 11px;
    color: var(--text-dim);
  }

  .feed-card-author {
    font-weight: 500;
    color: var(--text);
  }

  .feed-card-model {
    background: var(--bg);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 10px;
  }
  .feed-card-thumb {
    margin: -14px -16px 10px -16px;
    border-radius: 10px 10px 0 0;
    overflow: hidden;
    background: var(--bg);
    max-height: 140px;
  }
  .feed-card-thumb img {
    width: 100%;
    height: auto;
    max-height: 140px;
    object-fit: cover;
    display: block;
  }

  .feed-backdrop {
    display: none !important;
  }

</style>
</head>
<body>

<!-- Toolbar -->
<div class="toolbar">
  <div class="nav-buttons">
    <button class="nav-btn" id="backBtn" disabled title="Back">&#8592;</button>
    <button class="nav-btn" id="forwardBtn" disabled title="Forward">&#8594;</button>
    <button class="nav-btn" id="homeBtn" title="Home"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="16" height="16" fill="currentColor"><path d="M240-200h120v-240h240v240h120v-360L480-740 240-560v360Zm-80 80v-480l320-240 320 240v480H520v-240h-80v240H160Zm320-350Z"/></svg></button>
  </div>

  <div class="address-bar">
    <span class="address-prefix">sidenet://</span>
    <input
      type="text"
      class="address-input"
      id="addressInput"
      placeholder="make up a url"
      autocomplete="off"
    />
  </div>

  <button class="go-btn" id="goBtn">Go</button>

  <div class="toolbar-right">
    <select class="model-select" id="modelSelect">
      <optgroup label="Free Models">
        <option value="nova-fast">Nova Micro — fastest, lightweight (22.2K/p)</option>
        <option value="mistral">Mistral Small 3.2 — compact, reliable (4.3K/p)</option>
        <option value="gemini-fast">Gemini 2.5 Flash — quick, balanced (3.1K/p)</option>
        <option value="qwen-coder">Qwen3 Coder 30B — code, technical (1.2K/p)</option>
        <option value="openai-fast">GPT-5 Nano — fast, versatile (950/p)</option>
        <option value="openai" selected>GPT-5 Mini — solid default (700/p)</option>
        <option value="claude-fast">Claude Haiku 4.5 — smart, concise (95/p)</option>
      </optgroup>
      <optgroup label="Paid Models (requires Pollen)">
        <option value="openai-large">GPT-5.2 — powerful, detailed (90/p)</option>
        <option value="gemini">Gemini 3 Flash — fast, premium (85/p)</option>
        <option value="grok">Grok 4 Fast — creative, bold (550/p)</option>
        <option value="claude">Claude Sonnet 4.5 — best quality (25/p)</option>
      </optgroup>
    </select>
    <button class="settings-btn" id="feedBtn" title="Community Feed">&#9733;</button>
    <button class="settings-btn" id="historyBtn" title="History">&#9776;</button>
    <div class="settings-btn-wrapper">
      <button class="settings-btn" id="settingsBtn" title="Settings">&#9881;</button>
      <div class="connection-dot" id="connectionDot"></div>
      <div class="connection-dot-tooltip">Get a free key at enter.pollinations.ai &rarr; paste in Settings</div>
    </div>
  </div>
</div>

<!-- Main row: content + feed sidebar -->
<div class="main-row" id="mainRow">
  <!-- Main content -->
  <div class="content-area" id="contentArea">
    <div class="page-container" id="pageContainer">
      <div class="welcome-header">
        <div class="welcome-logo">sidenet</div>
      </div>
      <div class="welcome-feed-section">
        <div class="welcome-feed-header">
          <h3>Today's Catch</h3>
          <button class="settings-btn" onclick="loadWelcomeFeed()" title="Refresh" style="width:auto;padding:0 8px;font-size:12px;height:28px">Refresh</button>
        </div>
        <div class="welcome-feed-list" id="welcomeFeedList">
          <div class="feed-empty">Scanning the airwaves...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Feed panel (inline sidebar) -->
  <div class="feed-panel" id="feedPanel">
    <div class="feed-header">
      <h3>Community Feed</h3>
      <div class="feed-header-actions">
        <button id="refreshFeedBtn">Refresh</button>
        <button id="closeFeedBtn">Close</button>
      </div>
    </div>
    <div class="feed-list" id="feedList">
      <div class="feed-empty">Scanning the airwaves...</div>
    </div>
  </div>
</div>

<div class="feed-backdrop" id="feedBackdrop"></div>

<!-- History panel -->
<div class="history-backdrop" id="historyBackdrop"></div>
<div class="history-panel" id="historyPanel">
  <div class="history-header">
    <h3>History</h3>
    <div class="history-header-actions">
      <button id="clearHistoryBtn">Clear all</button>
      <button id="closeHistoryBtn">Close</button>
    </div>
  </div>
  <div class="history-list" id="historyList">
    <div class="history-empty">No pages visited yet.</div>
  </div>
</div>

<!-- Settings modal -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal">
    <h2>Settings</h2>
    <div class="form-group">
      <label>Pollinations API Key</label>
      <input type="password" id="apiKeyInput" placeholder="pk_... or sk_..." />
      <div class="form-hint">
        Optional for free models. Get a key at <a href="https://enter.pollinations.ai" target="_blank" style="color:var(--accent)">enter.pollinations.ai</a>
      </div>
      <div id="balanceDisplay" style="margin-top:6px;font-size:13px;color:var(--green);display:none">
        <span id="balanceAmount"></span>
      </div>
    </div>
    <div class="form-group">
      <label>Images per page (1-3)</label>
      <input type="number" id="imagesPerPage" min="1" max="3" value="2" />
      <div class="form-hint">How many AI images to generate per page</div>
    </div>
    <div class="form-group">
      <label>Temperature</label>
      <div class="temperature-control">
        <input type="range" id="temperatureSlider" min="0" max="2" step="0.05" value="0.85" />
        <span class="temperature-value" id="temperatureValue">0.85</span>
      </div>
      <div class="form-hint">Lower = more focused, Higher = more creative (default: 0.85)</div>
    </div>
    <div class="form-group">
      <label>System Prompt</label>
      <div class="prompt-preset-row">
        <select id="promptPresetSelect"></select>
        <button class="btn-icon" id="editPromptsBtn" title="Edit system prompts">&#9998;</button>
      </div>
      <div class="form-hint">Controls the AI's behavior and page generation style</div>
      <div class="tonal-modifier-display" id="tonalModifierDisplay" style="display:none">
        <span class="tonal-modifier-label">session tone:</span>
        <span id="tonalModifierValue"></span>
      </div>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:20px 0" />
    <div class="form-group">
      <label>Display Name (for community feed)</label>
      <input type="text" id="displayNameInput" placeholder="Anonymous" style="font-family:inherit" />
      <div class="form-hint">Shown when you share pages to the feed</div>
    </div>
    <div class="modal-actions">
      <button class="btn-secondary" id="cancelSettings">Cancel</button>
      <button class="btn-primary" id="saveSettings">Save</button>
    </div>
  </div>
</div>

<!-- System Prompt Editor modal -->
<div class="modal-overlay prompt-editor-overlay" id="promptEditorModal">
  <div class="modal prompt-editor-modal">
    <h2>Edit System Prompt</h2>
    <div class="form-group">
      <label>Preset Name</label>
      <input type="text" id="promptNameInput" placeholder="My Custom Prompt" style="font-family:inherit" />
    </div>
    <div class="form-group">
      <label>System Prompt</label>
      <textarea id="promptTextarea" placeholder="Enter your system prompt here..."></textarea>
    </div>
    <div class="prompt-editor-actions">
      <div class="left-actions">
        <button class="btn-danger" id="deletePromptBtn">Delete</button>
        <button class="btn-secondary" id="resetPromptBtn">Reset to Default</button>
      </div>
      <div class="right-actions">
        <button class="btn-secondary" id="saveAsNewPromptBtn">Save as New</button>
        <button class="btn-primary" id="savePromptBtn">Save</button>
        <button class="btn-secondary" id="closePromptEditorBtn">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Duplicate URL modal -->
<div class="modal-overlay" id="duplicateModal">
  <div class="modal" style="width:380px;text-align:center">
    <h2 style="font-size:16px;margin-bottom:12px">Page Already Exists</h2>
    <p style="color:var(--text-dim);font-size:14px;margin-bottom:20px;line-height:1.6">
      A page like this has already been unearthed. Explore there instead?
    </p>
    <div class="modal-actions" style="justify-content:center">
      <button class="btn-secondary" id="duplicateNo">No, generate new</button>
      <button class="btn-primary" id="duplicateYes">Yes, take me there</button>
    </div>
  </div>
</div>

<script>
// ── State ──
// ── Firebase config (injected at build time) ──
const FIREBASE_CONFIG = {
  apiKey: "__FIREBASE_API_KEY__",
  authDomain: "__FIREBASE_AUTH_DOMAIN__",
  databaseURL: "__FIREBASE_DATABASE_URL__",
  projectId: "__FIREBASE_PROJECT_ID__",
  storageBucket: "__FIREBASE_STORAGE_BUCKET__",
  messagingSenderId: "__FIREBASE_MESSAGING_SENDER_ID__",
  appId: "__FIREBASE_APP_ID__",
};

const DEFAULT_SYSTEM_PROMPT = `You are sidenet, an AI that generates creative, detailed pages for an alternate-reality internet browser.

FORMAT:
Always output your response in three labeled sections, each starting with a delimiter on its own line:

===HTML===
(page body content — no <html>, <head>, or <body> tags)
===CSS===
(styles for your page — use @import for Google Fonts if desired)
===JS===
(JavaScript for interactivity — optional, leave empty if not needed)

RULES:
- Use semantic HTML: h1, h2, h3, p, ul, ol, blockquote, table, pre, code, hr, etc.
- Include 1-3 images: <img data-ai-prompt="detailed description" alt="description" />
- Include 3-6 hyperlinks: <a href="sidenet://some-url-path">Link Text</a>
  - Use creative URLs like sidenet://en.wikipedia.alt/wiki/Topic
- Make content creative, detailed, internally consistent, and immersive
- Pages should feel like real websites from a parallel universe
- Content should be 300-600 words
- Use JS for interactive elements (tabs, toggles, animations, calculators, etc.)
- JS can use querySelector/getElementById to reference your HTML elements
- Do NOT output markdown code fences — just the raw sections`;

const state = {
  apiKey: localStorage.getItem('sidenet_apiKey') || '',
  imagesPerPage: parseInt(localStorage.getItem('sidenet_imagesPerPage') || '2'),
  displayName: localStorage.getItem('sidenet_displayName') || '',
  temperature: parseFloat(localStorage.getItem('sidenet_temperature') || '0.85'),
  activePromptId: localStorage.getItem('sidenet_activePromptId') || 'default',
  systemPromptPresets: JSON.parse(localStorage.getItem('sidenet_systemPromptPresets') || 'null') || {
    default: { name: 'Default sidenet', prompt: DEFAULT_SYSTEM_PROMPT }
  },
  history: [],
  historyIndex: -1,
  isLoading: false,
  firebaseReady: false,
  firebaseUid: null,
  settingsSynced: false,
  currentFeedKey: null,
  currentExplorationId: null,
  tonalModifier: null,
  feedClosedByUser: false,
};

// ── DOM refs ──
const $ = (sel) => document.querySelector(sel);
const addressInput = $('#addressInput');
const goBtn = $('#goBtn');
const backBtn = $('#backBtn');
const forwardBtn = $('#forwardBtn');
const homeBtn = $('#homeBtn');
const modelSelect = $('#modelSelect');
const settingsBtn = $('#settingsBtn');
const settingsModal = $('#settingsModal');
const apiKeyInput = $('#apiKeyInput');
const imagesPerPageInput = $('#imagesPerPage');
const saveSettingsBtn = $('#saveSettings');
const cancelSettingsBtn = $('#cancelSettings');
const pageContainer = $('#pageContainer');
const connectionDot = $('#connectionDot');
const historyBtn = $('#historyBtn');
const historyPanel = $('#historyPanel');
const historyBackdrop = $('#historyBackdrop');
const historyList = $('#historyList');
const clearHistoryBtn = $('#clearHistoryBtn');
const closeHistoryBtn = $('#closeHistoryBtn');
const feedBtn = $('#feedBtn');
const feedPanel = $('#feedPanel');
const feedBackdrop = $('#feedBackdrop');
const feedList = $('#feedList');
const refreshFeedBtn = $('#refreshFeedBtn');
const closeFeedBtn = $('#closeFeedBtn');
const displayNameInput = $('#displayNameInput');
const welcomeFeedList = $('#welcomeFeedList');
const temperatureSlider = $('#temperatureSlider');
const temperatureValue = $('#temperatureValue');
const promptPresetSelect = $('#promptPresetSelect');
const editPromptsBtn = $('#editPromptsBtn');
const promptEditorModal = $('#promptEditorModal');
const promptNameInput = $('#promptNameInput');
const promptTextarea = $('#promptTextarea');
const deletePromptBtn = $('#deletePromptBtn');
const resetPromptBtn = $('#resetPromptBtn');
const saveAsNewPromptBtn = $('#saveAsNewPromptBtn');
const savePromptBtn = $('#savePromptBtn');
const closePromptEditorBtn = $('#closePromptEditorBtn');

// ── Init ──
let firebaseDb = null;
let firebaseAuth = null;
let firebaseStorage = null;
updateStatusBar();
apiKeyInput.value = state.apiKey;
imagesPerPageInput.value = state.imagesPerPage;
displayNameInput.value = state.displayName;
temperatureSlider.value = state.temperature;
temperatureValue.textContent = state.temperature.toFixed(2);
populatePromptPresetSelect();
initFirebase();

// ── Animated favicon ──
(function() {
  const SURFER_PATH = 'M80-40v-80h40q32 0 62-10t58-30q28 20 58 29.5t62 9.5q32 0 62.5-9.5T480-160q28 20 58 29.5t62 9.5q32 0 62.5-9.5T720-160q27 20 57.5 30t62.5 10h40v80h-40q-31 0-61-7.5T720-70q-29 15-59 22.5T600-40q-31 0-61-7.5T480-70q-29 15-59 22.5T360-40q-31 0-61-7.5T240-70q-29 15-59 22.5T120-40H80Zm260-760 222 41q14 2 27 11t22 25l35 62q26 45 72 73t102 28v80q-78 0-142-39T577-621l-90 61 153 120v154q16 11 31 23t29 23q-21 18-46 29t-54 11q-36 0-67-17t-53-43q-22 26-53 43t-67 17q-10 0-19.5-1.5T322-206q-86-59-144-119t-58-104q0-31 24-41t50-10q29 0 67 8.5t81 24.5l-21-124q-4-20 4.5-39.5T352-642l86-58q-3 0-14.5-2.5t-25.5-5-25.5-5Q361-715 358-715l-113 77-45-66 140-96Zm72 284 18 106q27 13 67 34.5t63 35.5v-60L412-516Zm268-224q-33 0-56.5-23.5T600-820q0-33 23.5-56.5T680-900q33 0 56.5 23.5T760-820q0 33-23.5 56.5T680-740Z';
  const PRIDE_COLORS = [
    '#000000', '#613915', '#5bcefa', '#f5a9b8', '#ffffff',
    '#e40303', '#ff8c00', '#ffed00', '#008026', '#004dff', '#750787'
  ];
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const faviconLink = document.querySelector('link[rel="icon"]');
  let phase = 0;
  let faviconInterval = null;

  function lerpColor(a, b, t) {
    const ah = parseInt(a.slice(1), 16), bh = parseInt(b.slice(1), 16);
    const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    const r = Math.round(ar + (br - ar) * t);
    const g = Math.round(ag + (bg - ag) * t);
    const b2 = Math.round(ab + (bb - ab) * t);
    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b2).toString(16).slice(1);
  }

  function getColorAt(t) {
    t = ((t % 1) + 1) % 1;
    const pos = t * (PRIDE_COLORS.length - 1);
    const i = Math.floor(pos);
    const frac = pos - i;
    return lerpColor(PRIDE_COLORS[Math.min(i, PRIDE_COLORS.length - 1)],
                     PRIDE_COLORS[Math.min(i + 1, PRIDE_COLORS.length - 1)], frac);
  }

  function renderFavicon() {
    ctx.clearRect(0, 0, 64, 64);
    const grad = ctx.createRadialGradient(20, 20, 4, 36, 36, 60);
    grad.addColorStop(0, getColorAt(phase));
    grad.addColorStop(0.5, getColorAt(phase + 0.15));
    grad.addColorStop(1, getColorAt(phase + 0.3));
    ctx.save();
    ctx.scale(64/960, 64/960);
    ctx.translate(0, 960);
    const p = new Path2D(SURFER_PATH);
    ctx.fillStyle = grad;
    ctx.fill(p);
    ctx.restore();
    faviconLink.href = canvas.toDataURL('image/png');
    phase = (phase + 0.02) % 1;
  }

  function startFaviconCycle() {
    if (!faviconInterval) {
      faviconInterval = setInterval(renderFavicon, 200);
      renderFavicon();
    }
  }

  function stopFaviconCycle() {
    if (faviconInterval) {
      clearInterval(faviconInterval);
      faviconInterval = null;
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stopFaviconCycle();
    else startFaviconCycle();
  });

  if (!document.hidden) startFaviconCycle();
})();

// ── Iframe postMessage bridge ──
window.addEventListener('message', (e) => {
  if (e.data?.type === 'sidenet-navigate') {
    let href = e.data.href.replace(/^(sidenet|side):\/\//, '');
    navigateTo(href, {
      parentFeedKey: state.currentFeedKey,
      explorationId: state.currentExplorationId,
      parentHtml: pageContainer.innerHTML,
    });
  }
  if (e.data?.type === 'sidenet-resize') {
    const iframe = pageContainer.querySelector('iframe');
    if (iframe) iframe.style.height = e.data.height + 'px';
  }
});

// ── Settings ──
settingsBtn.addEventListener('click', () => {
  settingsModal.classList.add('open');
  apiKeyInput.value = state.apiKey;
  imagesPerPageInput.value = state.imagesPerPage;
  displayNameInput.value = state.displayName;
  temperatureSlider.value = state.temperature;
  temperatureValue.textContent = state.temperature.toFixed(2);
  populatePromptPresetSelect();
  fetchBalance();
  const modDisplay = $('#tonalModifierDisplay');
  const modValue = $('#tonalModifierValue');
  if (state.tonalModifier) {
    modValue.textContent = state.tonalModifier;
    modDisplay.style.display = '';
  } else {
    modDisplay.style.display = 'none';
  }
});

cancelSettingsBtn.addEventListener('click', () => settingsModal.classList.remove('open'));

temperatureSlider.addEventListener('input', () => {
  temperatureValue.textContent = parseFloat(temperatureSlider.value).toFixed(2);
});

settingsModal.addEventListener('click', (e) => {
  if (e.target === settingsModal) settingsModal.classList.remove('open');
});

saveSettingsBtn.addEventListener('click', () => {
  state.apiKey = apiKeyInput.value.trim();
  state.imagesPerPage = Math.min(3, Math.max(1, parseInt(imagesPerPageInput.value) || 2));
  state.displayName = displayNameInput.value.trim();
  state.temperature = parseFloat(temperatureSlider.value);
  state.activePromptId = promptPresetSelect.value;
  localStorage.setItem('sidenet_apiKey', state.apiKey);
  localStorage.setItem('sidenet_imagesPerPage', state.imagesPerPage);
  localStorage.setItem('sidenet_displayName', state.displayName);
  localStorage.setItem('sidenet_temperature', state.temperature);
  localStorage.setItem('sidenet_activePromptId', state.activePromptId);
  saveSettingsToFirebase();
  settingsModal.classList.remove('open');
  updateStatusBar();
});

function updateStatusBar() {
  if (!connectionDot) return;
  if (state.apiKey) {
    connectionDot.classList.add('connected');
  } else {
    connectionDot.classList.remove('connected');
  }
}

const POLLEN_PER_RESPONSE = {
  'nova-fast': 22200, 'mistral': 4300, 'gemini-fast': 3100,
  'qwen-coder': 1200, 'openai-fast': 950, 'openai': 700,
  'grok': 550, 'claude-fast': 95, 'openai-large': 90,
  'gemini': 85, 'claude': 25,
};

async function fetchBalance() {
  const el = document.getElementById('balanceDisplay');
  const amt = document.getElementById('balanceAmount');
  if (!el || !amt) return;
  if (!state.apiKey) { el.style.display = 'none'; return; }
  try {
    const resp = await fetch('https://gen.pollinations.ai/account/balance', {
      headers: { 'Authorization': `Bearer ${state.apiKey}` }
    });
    if (!resp.ok) throw new Error('Failed');
    const data = await resp.json();
    const balance = typeof data === 'number' ? data : (data.balance ?? data);
    const model = modelSelect.value;
    const rate = POLLEN_PER_RESPONSE[model];
    const estGen = rate ? `~${Math.floor(balance * rate).toLocaleString()} pages on ${modelSelect.options[modelSelect.selectedIndex].text.split(' — ')[0]}` : '';
    amt.textContent = `${Number(balance).toFixed(2)} pollen${estGen ? ' · ' + estGen : ''}`;
    el.style.display = 'block';
  } catch {
    el.style.display = 'none';
  }
}

// ── System Prompt Presets ──
function populatePromptPresetSelect() {
  promptPresetSelect.innerHTML = '';
  for (const [id, preset] of Object.entries(state.systemPromptPresets)) {
    const opt = document.createElement('option');
    opt.value = id;
    opt.textContent = preset.name;
    promptPresetSelect.appendChild(opt);
  }
  promptPresetSelect.value = state.activePromptId;
  if (!promptPresetSelect.value && promptPresetSelect.options.length > 0) {
    promptPresetSelect.value = promptPresetSelect.options[0].value;
    state.activePromptId = promptPresetSelect.value;
  }
}

function savePresetsToStorage() {
  localStorage.setItem('sidenet_systemPromptPresets', JSON.stringify(state.systemPromptPresets));
  localStorage.setItem('sidenet_activePromptId', state.activePromptId);
  saveSettingsToFirebase();
}

function getActiveSystemPrompt() {
  const preset = state.systemPromptPresets[state.activePromptId];
  return preset ? preset.prompt : DEFAULT_SYSTEM_PROMPT;
}

editPromptsBtn.addEventListener('click', () => {
  const currentId = promptPresetSelect.value || state.activePromptId;
  const preset = state.systemPromptPresets[currentId];
  promptNameInput.value = preset ? preset.name : '';
  promptTextarea.value = preset ? preset.prompt : DEFAULT_SYSTEM_PROMPT;
  deletePromptBtn.disabled = (currentId === 'default');
  promptEditorModal.classList.add('open');
});

closePromptEditorBtn.addEventListener('click', () => {
  promptEditorModal.classList.remove('open');
});

promptEditorModal.addEventListener('click', (e) => {
  if (e.target === promptEditorModal) promptEditorModal.classList.remove('open');
});

savePromptBtn.addEventListener('click', () => {
  const currentId = promptPresetSelect.value || state.activePromptId;
  state.systemPromptPresets[currentId] = {
    name: promptNameInput.value.trim() || 'Untitled',
    prompt: promptTextarea.value,
  };
  state.activePromptId = currentId;
  savePresetsToStorage();
  populatePromptPresetSelect();
  promptEditorModal.classList.remove('open');
});

saveAsNewPromptBtn.addEventListener('click', () => {
  const newId = 'custom_' + Date.now();
  state.systemPromptPresets[newId] = {
    name: promptNameInput.value.trim() || 'Untitled',
    prompt: promptTextarea.value,
  };
  state.activePromptId = newId;
  savePresetsToStorage();
  populatePromptPresetSelect();
  promptEditorModal.classList.remove('open');
});

deletePromptBtn.addEventListener('click', () => {
  const currentId = promptPresetSelect.value || state.activePromptId;
  if (currentId === 'default') return;
  if (!confirm('Delete this prompt preset?')) return;
  delete state.systemPromptPresets[currentId];
  state.activePromptId = 'default';
  savePresetsToStorage();
  populatePromptPresetSelect();
  const d = state.systemPromptPresets['default'];
  promptNameInput.value = d.name;
  promptTextarea.value = d.prompt;
  deletePromptBtn.disabled = true;
});

resetPromptBtn.addEventListener('click', () => {
  promptTextarea.value = DEFAULT_SYSTEM_PROMPT;
  promptNameInput.value = 'Default sidenet';
});

// ── Navigation ──
const welcomeHTML = pageContainer.innerHTML;

// Browser URL integration — each page gets a clean /s/ path
function updateBrowserUrl(sidenetUrl) {
  if (sidenetUrl) {
    history.pushState({ sidenetUrl }, '', '/s/' + sidenetUrl);
  } else {
    history.pushState({ sidenetUrl: null }, '', '/');
  }
}

function isOnPage() {
  return window.location.pathname.startsWith('/s/');
}

function getSidenetUrlFromPath() {
  const path = window.location.pathname;
  if (path.startsWith('/s/')) return path.slice(3);
  return null;
}

function goHome() {
  pageContainer.innerHTML = welcomeHTML;
  addressInput.value = '';
  state.historyIndex = -1;
  state.currentFeedKey = null;
  state.currentExplorationId = null;
  state.tonalModifier = null;
  updateNavButtons();
  updateBrowserUrl(null);
  toggleFeed(false);
  state.feedClosedByUser = false;
  loadWelcomeFeed();
}

homeBtn.addEventListener('click', goHome);

// Handle browser back/forward
window.addEventListener('popstate', (e) => {
  const sidenetUrl = (e.state && e.state.sidenetUrl) || getSidenetUrlFromPath();
  if (!sidenetUrl) {
    // Going back to homepage
    pageContainer.innerHTML = welcomeHTML;
    addressInput.value = '';
    state.currentFeedKey = null;
    state.currentExplorationId = null;
    state.tonalModifier = null;
    toggleFeed(false);
    state.feedClosedByUser = false;
    loadWelcomeFeed();
    // Sync with internal history
    if (state.historyIndex > 0) state.historyIndex--;
    updateNavButtons();
  } else {
    // Going to a page — find it in internal history
    addressInput.value = sidenetUrl;
    const found = state.history.find(h => h.url === sidenetUrl);
    if (found && found.html) {
      restorePage(found.html);
      if (!state.feedClosedByUser) toggleFeed(true);
    } else {
      navigateTo(sidenetUrl);
    }
    updateNavButtons();
  }
});

addressInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !state.isLoading) {
    navigateTo(addressInput.value.trim());
  }
});

goBtn.addEventListener('click', () => {
  if (!state.isLoading) navigateTo(addressInput.value.trim());
});

backBtn.addEventListener('click', () => {
  if (state.historyIndex > 0) {
    state.historyIndex--;
    const entry = state.history[state.historyIndex];
    addressInput.value = entry.url;
    restorePage(entry.html);
    updateNavButtons();
    updateBrowserUrl(entry.url);
  }
});

forwardBtn.addEventListener('click', () => {
  if (state.historyIndex < state.history.length - 1) {
    state.historyIndex++;
    const entry = state.history[state.historyIndex];
    addressInput.value = entry.url;
    restorePage(entry.html);
    updateNavButtons();
    updateBrowserUrl(entry.url);
  }
});

function updateNavButtons() {
  backBtn.disabled = state.historyIndex <= 0;
  forwardBtn.disabled = state.historyIndex >= state.history.length - 1;
}

// ── Duplicate URL detection ──
function checkDuplicateUrl(query) {
  return new Promise((resolve) => {
    if (!state.firebaseReady || !firebaseDb) { resolve(null); return; }
    firebaseDb.ref('feed')
      .orderByChild('url')
      .equalTo(query.toLowerCase())
      .once('value')
      .then(snap => {
        if (snap.exists()) {
          const entries = [];
          snap.forEach(child => entries.push({ key: child.key, ...child.val() }));
          entries.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
          resolve(entries[0]);
        } else {
          resolve(null);
        }
      })
      .catch(() => resolve(null));
  });
}

function showDuplicateModal() {
  return new Promise((resolve) => {
    const modal = document.getElementById('duplicateModal');
    const yesBtn = document.getElementById('duplicateYes');
    const noBtn = document.getElementById('duplicateNo');
    modal.classList.add('open');
    function cleanup() {
      modal.classList.remove('open');
      yesBtn.removeEventListener('click', onYes);
      noBtn.removeEventListener('click', onNo);
      modal.removeEventListener('click', onBackdrop);
    }
    function onYes() { cleanup(); resolve('existing'); }
    function onNo() { cleanup(); resolve('generate'); }
    function onBackdrop(e) { if (e.target === modal) { cleanup(); resolve('generate'); } }
    yesBtn.addEventListener('click', onYes);
    noBtn.addEventListener('click', onNo);
    modal.addEventListener('click', onBackdrop);
  });
}

// ── Main page generation ──
async function navigateTo(query, { parentFeedKey, explorationId, parentHtml } = {}) {
  if (!query) return;

  // Check for duplicate URL in community feed
  const existingEntry = await checkDuplicateUrl(query);
  if (existingEntry) {
    const choice = await showDuplicateModal();
    if (choice === 'existing') {
      addressInput.value = existingEntry.url;
      restorePage(existingEntry.html);
      state.history = state.history.slice(0, state.historyIndex + 1);
      state.history.push({ url: existingEntry.url, html: existingEntry.html });
      state.historyIndex = state.history.length - 1;
      updateNavButtons();
      state.currentFeedKey = existingEntry.key || null;
      state.currentExplorationId = existingEntry.explorationId || null;
      updateBrowserUrl(existingEntry.url);
      if (!state.feedClosedByUser) toggleFeed(true);
      $('#contentArea').scrollTop = 0;
      return;
    }
  }

  state.isLoading = true;
  goBtn.disabled = true;
  addressInput.value = query;

  // Show loading with cycling immersive messages
  const loadingMessages = [
    'searching the records...',
    'exploring a new path...',
    'digging something up...',
    'tracing a signal...',
    'following a thread...',
    'pulling from the archive...',
    'navigating the deep net...',
    'decoding the broadcast...',
    'tuning into a frequency...',
    'unearthing an artifact...',
    'opening a sealed channel...',
    'sifting through the noise...',
  ];
  const loadMsg = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
  pageContainer.innerHTML = `
    <div class="loading-container">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">${loadMsg}</div>
      <div class="loading-step" id="loadingStep"></div>
    </div>
  `;
  const loadingInterval = setInterval(() => {
    const el = $('#loadingText');
    if (!el) { clearInterval(loadingInterval); return; }
    el.textContent = loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
  }, 3000);

  // Determine storage URL (add suffix if duplicate)
  let storageUrl = query.toLowerCase();
  if (existingEntry) {
    try {
      const snap = await firebaseDb.ref('feed')
        .orderByChild('url')
        .startAt(query.toLowerCase())
        .endAt(query.toLowerCase() + '\uf8ff')
        .once('value');
      let count = 0;
      if (snap.exists()) snap.forEach(() => count++);
      storageUrl = query.toLowerCase() + '~' + (count + 1);
    } catch { /* use base url */ }
  }

  try {
    // Generate tonal modifier for new explorations (not link clicks)
    if (!parentFeedKey) {
      state.tonalModifier = await generateTonalModifier(query);
    }

    // Step 1: Generate page HTML
    const pageHTML = await generatePage(query);

    // Step 2: Parse structured response into HTML/CSS/JS
    const { html: rawHtml, css, js } = parseStructuredResponse(pageHTML);
    const { html: processedHtml, imagePrompts } = parseAndInsertImages(rawHtml);

    // Step 3: Render page (iframe for JS, direct DOM for CSS-only)
    if (js.trim()) {
      const resolved = resolveImagesForIframe(processedHtml, imagePrompts);
      renderStructuredPage(resolved, css, js);
    } else {
      renderStructuredPage(processedHtml, css, '');
      const limitedPrompts = imagePrompts.slice(0, state.imagesPerPage);
      if (limitedPrompts.length > 0) {
        await generateImages(limitedPrompts);
      }
      bindPageLinks();
    }

    // Save to session history (pack structured content for storage)
    const packed = packPageContent(processedHtml, css, js);
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push({ url: query, html: packed });
    state.historyIndex = state.history.length - 1;
    updateNavButtons();
    updateBrowserUrl(query);

    // Save to persistent history
    const pageTitle = extractTitle(processedHtml) || query;
    const now = Date.now();
    savePersistentHistory({
      url: query,
      title: pageTitle,
      html: packed,
      timestamp: now,
      model: modelSelect.value,
    });

    // Auto-publish to community feed and track exploration tree
    const feedKey = await publishToFeed(storageUrl, pageTitle, packed);
    state.currentFeedKey = feedKey;
    await updateExplorationTree(query, pageTitle, feedKey, packed, { parentFeedKey, explorationId, parentHtml });

    // Capture screenshot asynchronously (don't block page display)
    if (feedKey) {
      if (js.trim()) {
        captureHtmlAsScreenshot(processedHtml, css, feedKey).then(url => {
          if (url) updateNodeScreenshot(feedKey, state.currentExplorationId, url);
        });
      } else {
        const imgs = pageContainer.querySelectorAll('.page-image');
        const waits = [...imgs].map(img =>
          img.complete ? Promise.resolve() : new Promise(r => { img.onload = r; img.onerror = r; setTimeout(r, 10000); })
        );
        Promise.allSettled(waits).then(() => {
          captureAndUploadScreenshot(feedKey).then(url => {
            if (url) updateNodeScreenshot(feedKey, state.currentExplorationId, url);
          });
        });
      }
    }

    // Scroll to top
    $('#contentArea').scrollTop = 0;

    // Auto-open feed sidebar unless user closed it
    if (!state.feedClosedByUser) {
      toggleFeed(true);
    }

  } catch (err) {
    pageContainer.innerHTML = `
      <div class="page-container">
        <div class="error-banner">
          <strong>Connection failed:</strong> ${escapeHtml(err.message)}
        </div>
        <p style="color:var(--text-dim);margin-top:12px;">
          Check your API key in settings, or try a different model.
        </p>
      </div>
    `;
  }

  clearInterval(loadingInterval);
  state.isLoading = false;
  goBtn.disabled = false;
}

// ── Text generation ──
async function generatePage(query) {
  const model = modelSelect.value;
  let systemPrompt = getActiveSystemPrompt();
  if (state.tonalModifier) {
    systemPrompt += '\n\nTone: ' + state.tonalModifier;
  }

  const userPrompt = `Generate the webpage for: ${query}

This is a page on the alternate internet. Create rich, immersive content with images and links to other pages.`;

  const response = await fetch('https://gen.pollinations.ai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(state.apiKey ? { 'Authorization': `Bearer ${state.apiKey}` } : {}),
    },
    body: JSON.stringify({
      model: model,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      temperature: state.temperature,
      max_tokens: 2048,
    }),
  });

  if (!response.ok) {
    const errText = await response.text();
    throw new Error(`API error ${response.status}: ${errText.substring(0, 200)}`);
  }

  const data = await response.json();
  let content = data.choices[0].message.content;
  // Strip markdown code fences if the model wrapped its output
  content = content.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '');
  return content;
}

async function generateTonalModifier(url) {
  try {
    const response = await fetch('https://gen.pollinations.ai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(state.apiKey ? { 'Authorization': `Bearer ${state.apiKey}` } : {}),
      },
      body: JSON.stringify({
        model: 'nova-fast',
        messages: [
          { role: 'system', content: 'You generate tonal modifiers for creative writing. A tonal modifier is a short phrase (3-8 words) describing a mood, disposition, or emotional texture — NOT a theme, topic, or scenario. Examples: "wistful and slightly amused", "quietly conspiratorial", "warm but formally distant", "dreamlike with sharp edges". Respond with ONLY the phrase, no quotes, no punctuation at the end, no explanation.' },
          { role: 'user', content: url },
        ],
        temperature: 1.0,
        max_tokens: 30,
      }),
    });
    if (!response.ok) return null;
    const data = await response.json();
    let modifier = (data.choices[0].message.content || '').trim();
    modifier = modifier.replace(/^["']|["']$/g, '').replace(/[.!]$/, '').substring(0, 80);
    return modifier || null;
  } catch {
    return null;
  }
}

// ── Structured response parsing ──
function parseStructuredResponse(raw) {
  raw = raw.replace(/^```\w*\s*\n?/i, '').replace(/\n?```\s*$/i, '');
  const sectionRegex = /^===(\w+)===\s*$/gm;
  const matches = [];
  let m;
  while ((m = sectionRegex.exec(raw)) !== null) {
    matches.push({ name: m[1].toUpperCase(), end: m.index + m[0].length, index: m.index });
  }
  if (matches.length === 0) return { html: raw.trim(), css: '', js: '' };
  const sections = {};
  const before = raw.substring(0, matches[0].index).trim();
  for (let i = 0; i < matches.length; i++) {
    const start = matches[i].end;
    const end = i + 1 < matches.length ? matches[i + 1].index : raw.length;
    sections[matches[i].name] = raw.substring(start, end).trim();
  }
  return {
    html: [before, sections.HTML || ''].filter(Boolean).join('\n'),
    css: sections.CSS || '',
    js: sections.JS || '',
  };
}

function scopeCSS(cssText) {
  if (!cssText.trim()) return '';
  return cssText.replace(
    /(^|\})\s*([^{}@/][^{]*?)\s*\{/gm,
    (match, prefix, selectors) => {
      const scoped = selectors.split(',').map(s => {
        s = s.trim();
        if (!s || /^(from|to|\d+%)$/.test(s)) return s;
        if (s.includes('.generated-page')) return s;
        return `.generated-page ${s}`;
      }).join(', ');
      return `${prefix} ${scoped} {`;
    }
  );
}

function packPageContent(html, css, js) {
  if (!css && !js) return `<div class="generated-page">${html}</div>`;
  return JSON.stringify({ _s: 1, html, css, js });
}

function unpackPageContent(stored) {
  if (!stored) return { html: '', css: '', js: '' };
  if (stored.startsWith('{')) {
    try {
      const p = JSON.parse(stored);
      if (p._s) return { html: p.html || '', css: p.css || '', js: p.js || '' };
    } catch {}
  }
  return { html: stored, css: '', js: '' };
}

function renderStructuredPage(html, css, js) {
  let extracted = '';
  html = html.replace(/<style[^>]*>([\s\S]*?)<\/style>/gi, (_, inner) => { extracted += inner + '\n'; return ''; });
  const allCSS = scopeCSS(extracted + '\n' + css);
  if (js.trim()) {
    renderInIframe(html, allCSS, js);
  } else {
    const style = allCSS ? `<style>${allCSS}</style>` : '';
    pageContainer.innerHTML = `<div class="generated-page">${style}${html}</div>`;
  }
}

function renderInIframe(html, css, js) {
  const S = '<' + 'script>';
  const SE = '</' + 'script>';
  const doc = '<!DOCTYPE html><html><head>'
    + '<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">'
    + '<style>'
    + ':root{--bg:#1a1a1a;--text:#e0e0e0;--accent:#e8a0bf;--border:#333;--surface:#242424;--surface2:#2a2a2a;--text-dim:#888}'
    + 'body{background:var(--bg);color:var(--text);font-family:\'Ubuntu Condensed\',\'Segoe UI\',system-ui,sans-serif;line-height:1.7;padding:24px;margin:0}'
    + 'a{color:var(--accent);text-decoration:none;cursor:pointer}'
    + 'a:hover{color:#f0b8d0;border-bottom:1px solid #f0b8d0}'
    + 'img{max-width:100%;border-radius:8px;border:1px solid var(--border)}'
    + 'blockquote{border-left:3px solid var(--accent);padding:8px 16px;margin:14px 0;background:var(--surface);border-radius:0 6px 6px 0}'
    + 'table{width:100%;border-collapse:collapse}th,td{border:1px solid var(--border);padding:8px 12px;text-align:left}th{background:var(--surface2);font-weight:600}'
    + 'code{background:var(--surface2);padding:2px 6px;border-radius:4px;font-family:\'SF Mono\',\'Fira Code\',monospace;font-size:13px}'
    + 'pre{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:16px;overflow-x:auto}pre code{background:none;padding:0}'
    + 'hr{border:none;border-top:1px solid var(--border);margin:24px 0}'
    + '</style>'
    + '<style>' + css + '</style>'
    + '</head><body>'
    + html
    + S
    + '(function(){'
    + 'new ResizeObserver(function(){window.parent.postMessage({type:"sidenet-resize",height:document.body.scrollHeight},"*");}).observe(document.body);'
    + 'document.addEventListener("click",function(e){var a=e.target.closest("a[href]");if(a){e.preventDefault();window.parent.postMessage({type:"sidenet-navigate",href:a.getAttribute("href")},"*");}});'
    + '})();'
    + 'try{' + js + '}catch(e){console.error("[sidenet page]",e);}'
    + SE
    + '</body></html>';

  const iframe = document.createElement('iframe');
  iframe.sandbox = 'allow-scripts';
  iframe.srcdoc = doc;
  iframe.style.cssText = 'width:100%;border:none;min-height:400px;display:block;';
  pageContainer.innerHTML = '';
  pageContainer.appendChild(iframe);
}

function restorePage(stored) {
  const { html, css, js } = unpackPageContent(stored);
  if (css || js) {
    renderStructuredPage(html, css, js);
    if (!js.trim()) bindPageLinks();
  } else {
    pageContainer.innerHTML = html;
    bindPageLinks();
  }
}

function resolveImagesForIframe(html, imagePrompts) {
  const limited = imagePrompts.slice(0, state.imagesPerPage);
  let result = html;
  for (const { id, prompt } of limited) {
    const enc = encodeURIComponent(prompt);
    const params = new URLSearchParams({ model: 'flux', width: '768', height: '512', nologo: 'true' });
    if (state.apiKey) params.set('key', state.apiKey);
    const url = `https://image.pollinations.ai/prompt/${enc}?${params}`;
    result = result.replace(
      new RegExp(`<div class="image-placeholder" id="${id}">[^<]*</div>`),
      `<img class="page-image" alt="${escapeHtml(prompt)}" src="${url}" />`
    );
  }
  return result;
}

// ── Image handling ──
function parseAndInsertImages(html) {
  const imagePrompts = [];
  let idx = 0;

  // Find all <img data-ai-prompt="..."> tags and replace with placeholders
  const processed = html.replace(
    /<img\s+data-ai-prompt="([^"]+)"[^>]*\/?>/gi,
    (match, prompt) => {
      const id = `ai-img-${idx}`;
      imagePrompts.push({ id, prompt });
      idx++;
      return `<div class="image-placeholder" id="${id}">Generating image: "${escapeHtml(prompt.substring(0, 80))}..."</div>`;
    }
  );

  return { html: processed, imagePrompts };
}

async function generateImages(prompts) {
  const promises = prompts.map(async ({ id, prompt }) => {
    try {
      const encodedPrompt = encodeURIComponent(prompt);
      const params = new URLSearchParams({
        model: 'flux',
        width: '768',
        height: '512',
        nologo: 'true',
      });
      if (state.apiKey) params.set('key', state.apiKey);

      const url = `https://image.pollinations.ai/prompt/${encodedPrompt}?${params}`;

      // Create image element and wait for load
      const placeholder = document.getElementById(id);
      if (!placeholder) return;

      const img = document.createElement('img');
      img.className = 'page-image';
      img.alt = prompt;
      img.src = url;

      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => {
          // Fallback: try gen.pollinations.ai endpoint
          const fallbackUrl = `https://gen.pollinations.ai/image/${encodedPrompt}?${params}`;
          img.onerror = reject;
          img.src = fallbackUrl;
        };
        // timeout after 60s
        setTimeout(resolve, 60000);
      });

      placeholder.replaceWith(img);
    } catch {
      const placeholder = document.getElementById(id);
      if (placeholder) {
        placeholder.textContent = '[Image failed to load]';
        placeholder.style.animation = 'none';
        placeholder.style.opacity = '0.4';
      }
    }
  });

  await Promise.allSettled(promises);
}

// ── Link binding ──
function bindPageLinks() {
  if (pageContainer.querySelector('iframe')) return;
  const parentHtml = pageContainer.innerHTML;
  pageContainer.querySelectorAll('a[href]').forEach((link) => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      let href = link.getAttribute('href');
      // Strip sidenet:// or legacy side:// prefix
      href = href.replace(/^(sidenet|side):\/\//, '');
      navigateTo(href, {
        parentFeedKey: state.currentFeedKey,
        explorationId: state.currentExplorationId,
        parentHtml,
      });
    });
  });
}

// ── Persistent History ──
function loadSavedHistory() {
  try {
    return JSON.parse(localStorage.getItem('sidenet_history') || '[]');
  } catch { return []; }
}

function savePersistentHistory(entry) {
  const saved = loadSavedHistory();
  saved.unshift(entry);
  // Keep max 200 entries, trim HTML to avoid hitting storage limits
  const trimmed = saved.slice(0, 200).map(e => ({
    ...e,
    html: (e.html || '').substring(0, 50000),
  }));
  try {
    localStorage.setItem('sidenet_history', JSON.stringify(trimmed));
  } catch {
    // Storage full — drop oldest half
    const halved = trimmed.slice(0, 100);
    localStorage.setItem('sidenet_history', JSON.stringify(halved));
  }
}

function deleteSavedHistoryEntry(timestamp) {
  const saved = loadSavedHistory().filter(e => e.timestamp !== timestamp);
  localStorage.setItem('sidenet_history', JSON.stringify(saved));
  renderHistoryPanel();
}

function clearSavedHistory() {
  localStorage.removeItem('sidenet_history');
  renderHistoryPanel();
}

function extractTitle(html) {
  const m = html.match(/<h1[^>]*>(.*?)<\/h1>/i);
  if (m) {
    const tmp = document.createElement('div');
    tmp.innerHTML = m[1];
    return tmp.textContent.substring(0, 100);
  }
  return null;
}

function formatTime(ts) {
  const d = new Date(ts);
  return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function formatDateGroup(ts) {
  const d = new Date(ts);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const date = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  const diff = (today - date) / 86400000;
  if (diff === 0) return 'Today';
  if (diff === 1) return 'Yesterday';
  if (diff < 7) return d.toLocaleDateString([], { weekday: 'long' });
  return d.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
}

function renderHistoryPanel() {
  const saved = loadSavedHistory();
  if (saved.length === 0) {
    historyList.innerHTML = '<div class="history-empty">No pages visited yet.</div>';
    return;
  }

  let html = '';
  let currentGroup = '';

  for (const entry of saved) {
    const group = formatDateGroup(entry.timestamp);
    if (group !== currentGroup) {
      currentGroup = group;
      html += `<div class="history-date-group">${escapeHtml(group)}</div>`;
    }
    const title = escapeHtml(entry.title || entry.url);
    const url = escapeHtml(entry.url);
    const time = formatTime(entry.timestamp);
    html += `
      <div class="history-item" data-ts="${entry.timestamp}" data-url="${escapeHtml(entry.url)}">
        <div class="history-item-content">
          <div class="history-item-title">${title}</div>
          <div class="history-item-url">s/${url}</div>
        </div>
        <span class="history-item-time">${time}</span>
        <button class="history-item-delete" data-delete-ts="${entry.timestamp}" title="Remove">&times;</button>
      </div>`;
  }

  historyList.innerHTML = html;

  // Bind clicks
  historyList.querySelectorAll('.history-item').forEach(item => {
    item.addEventListener('click', (e) => {
      if (e.target.closest('.history-item-delete')) return;
      const ts = parseInt(item.dataset.ts);
      const entry = loadSavedHistory().find(e => e.timestamp === ts);
      if (entry && entry.html) {
        // Restore cached page
        addressInput.value = entry.url;
        restorePage(entry.html);
        // Push to session nav history
        state.history = state.history.slice(0, state.historyIndex + 1);
        state.history.push({ url: entry.url, html: entry.html });
        state.historyIndex = state.history.length - 1;
        updateNavButtons();
        updateBrowserUrl(entry.url);
        if (!state.feedClosedByUser) toggleFeed(true);
        $('#contentArea').scrollTop = 0;
      } else {
        // Re-generate if no cached HTML
        navigateTo(item.dataset.url);
      }
      toggleHistory(false);
    });
  });

  historyList.querySelectorAll('.history-item-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      deleteSavedHistoryEntry(parseInt(btn.dataset.deleteTs));
    });
  });
}

function toggleHistory(forceOpen) {
  const open = forceOpen !== undefined ? forceOpen : !historyPanel.classList.contains('open');
  historyPanel.classList.toggle('open', open);
  historyBackdrop.classList.toggle('open', open);
  if (open) renderHistoryPanel();
}

historyBtn.addEventListener('click', () => toggleHistory());
closeHistoryBtn.addEventListener('click', () => toggleHistory(false));
historyBackdrop.addEventListener('click', () => toggleHistory(false));
clearHistoryBtn.addEventListener('click', () => {
  if (confirm('Clear all browsing history?')) clearSavedHistory();
});

// ── Firebase & Community Feed ──

function initFirebase() {
  try {
    if (typeof firebase === 'undefined' || typeof firebase.auth === 'undefined') {
      setTimeout(initFirebase, 500);
      return;
    }
    if (!firebase.apps.length) {
      firebase.initializeApp(FIREBASE_CONFIG);
    }
    firebaseDb = firebase.database();
    firebaseAuth = firebase.auth();
    firebaseStorage = firebase.storage();

    firebaseAuth.onAuthStateChanged(async (user) => {
      if (user) {
        state.firebaseUid = user.uid;
        state.firebaseReady = true;
        await loadSettingsFromFirebase();
        // Check for path-based URL on initial load (e.g. /s/some.url/path)
        const initialUrl = getSidenetUrlFromPath();
        if (initialUrl) {
          navigateTo(initialUrl);
        } else {
          loadWelcomeFeed();
        }
      } else {
        firebaseAuth.signInAnonymously().catch((err) => {
          console.error('Anonymous auth failed:', err);
          state.firebaseReady = false;
          loadWelcomeFeed();
        });
      }
    });
  } catch (err) {
    console.error('Firebase init failed:', err);
    state.firebaseReady = false;
    loadWelcomeFeed();
  }
}

async function loadSettingsFromFirebase() {
  if (!state.firebaseReady || !firebaseDb || !state.firebaseUid) return;
  try {
    const snap = await firebaseDb.ref('users/' + state.firebaseUid + '/settings').once('value');
    const remote = snap.val();
    if (remote) {
      if (remote.temperature !== undefined) {
        state.temperature = remote.temperature;
        temperatureSlider.value = state.temperature;
        temperatureValue.textContent = state.temperature.toFixed(2);
      }
      if (remote.activePromptId !== undefined) {
        state.activePromptId = remote.activePromptId;
      }
      if (remote.systemPromptPresets !== undefined) {
        state.systemPromptPresets = remote.systemPromptPresets;
      }
      if (remote.displayName !== undefined) {
        state.displayName = remote.displayName;
        displayNameInput.value = state.displayName;
      }
      if (remote.imagesPerPage !== undefined) {
        state.imagesPerPage = remote.imagesPerPage;
        imagesPerPageInput.value = state.imagesPerPage;
      }
      populatePromptPresetSelect();
      localStorage.setItem('sidenet_temperature', state.temperature);
      localStorage.setItem('sidenet_activePromptId', state.activePromptId);
      localStorage.setItem('sidenet_systemPromptPresets', JSON.stringify(state.systemPromptPresets));
      localStorage.setItem('sidenet_displayName', state.displayName);
      localStorage.setItem('sidenet_imagesPerPage', state.imagesPerPage);
    } else {
      await saveSettingsToFirebase();
    }
    state.settingsSynced = true;
  } catch (err) {
    console.error('Failed to load settings from Firebase:', err);
  }
}

function saveSettingsToFirebase() {
  if (!state.firebaseReady || !firebaseDb || !state.firebaseUid) return;
  return firebaseDb.ref('users/' + state.firebaseUid + '/settings').set({
    temperature: state.temperature,
    activePromptId: state.activePromptId,
    systemPromptPresets: state.systemPromptPresets,
    displayName: state.displayName,
    imagesPerPage: state.imagesPerPage,
    lastUpdated: Date.now(),
  }).catch((err) => {
    console.error('Failed to save settings to Firebase:', err);
  });
}

function publishToFeed(url, title, html) {
  if (!state.firebaseReady || !firebaseDb) return Promise.resolve(null);
  const cleanHtml = html.substring(0, 40000);
  const { html: rawForPreview } = unpackPageContent(cleanHtml);
  const tmp = document.createElement('div');
  tmp.innerHTML = rawForPreview;
  const h1 = tmp.querySelector('h1');
  if (h1) h1.remove();
  const preview = tmp.textContent.substring(0, 200).trim();

  const newRef = firebaseDb.ref('feed').push();
  const feedKey = newRef.key;
  return newRef.set({
    url: url.toLowerCase(),
    title: title || url,
    preview,
    html: cleanHtml,
    author: state.displayName || 'Anonymous',
    model: modelSelect.value,
    timestamp: Date.now(),
    explorationId: null,
  }).then(() => { feedCache.at = 0; return feedKey; }).catch(() => null);
}

// ── Screenshot capture ──

async function captureAndUploadScreenshot(feedKey) {
  if (!firebaseStorage || !feedKey) return null;
  try {
    const target = pageContainer.querySelector('.generated-page');
    if (!target) return null;
    await new Promise(r => setTimeout(r, 300));
    const canvas = await html2canvas(target, {
      backgroundColor: '#1a1a1a',
      scale: 0.5,
      width: target.scrollWidth,
      height: Math.min(target.scrollHeight, 800),
      logging: false,
      useCORS: true,
      allowTaint: true,
    });
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.6));
    if (!blob || blob.size < 100) return null;
    const ref = firebaseStorage.ref('screenshots/' + feedKey + '.jpg');
    const snap = await ref.put(blob, { contentType: 'image/jpeg' });
    const downloadUrl = await snap.ref.getDownloadURL();
    await firebaseDb.ref('feed/' + feedKey + '/screenshotUrl').set(downloadUrl);
    return downloadUrl;
  } catch (err) {
    console.error('Screenshot capture failed:', err);
    return null;
  }
}

async function captureHtmlAsScreenshot(html, css, feedKey) {
  if (!firebaseStorage || !feedKey) return null;
  try {
    const offscreen = document.createElement('div');
    offscreen.className = 'generated-page';
    offscreen.style.cssText = 'position:fixed;top:-9999px;left:-9999px;width:800px;overflow:hidden;';
    if (css) {
      const style = document.createElement('style');
      style.textContent = css;
      offscreen.appendChild(style);
    }
    const content = document.createElement('div');
    content.innerHTML = html;
    offscreen.appendChild(content);
    document.body.appendChild(offscreen);
    await new Promise(r => setTimeout(r, 100));
    const canvas = await html2canvas(offscreen, {
      backgroundColor: '#1a1a1a',
      scale: 0.5,
      width: 800,
      height: Math.min(offscreen.scrollHeight, 800),
      logging: false,
    });
    document.body.removeChild(offscreen);
    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.6));
    if (!blob || blob.size < 100) return null;
    const ref = firebaseStorage.ref('screenshots/' + feedKey + '.jpg');
    const snap = await ref.put(blob, { contentType: 'image/jpeg' });
    const downloadUrl = await snap.ref.getDownloadURL();
    await firebaseDb.ref('feed/' + feedKey + '/screenshotUrl').set(downloadUrl);
    return downloadUrl;
  } catch (err) {
    console.error('Screenshot capture (offscreen) failed:', err);
    return null;
  }
}

async function updateNodeScreenshot(feedKey, explorationId, screenshotUrl) {
  if (!firebaseDb || !explorationId || !feedKey) return;
  try {
    const nodesSnap = await firebaseDb.ref('explorations/' + explorationId + '/nodes').once('value');
    if (nodesSnap.exists()) {
      nodesSnap.forEach(child => {
        if (child.val().feedKey === feedKey) {
          firebaseDb.ref('explorations/' + explorationId + '/nodes/' + child.key + '/screenshotUrl').set(screenshotUrl);
        }
      });
    }
  } catch (err) {
    console.error('Failed to update node screenshot:', err);
  }
}

function computeContentDiff(parentHtml, childHtml) {
  const toText = (h) => { const t = document.createElement('div'); t.innerHTML = h; return t.textContent || ''; };
  const parentWords = new Set(toText(parentHtml).toLowerCase().split(/\s+/).filter(w => w.length > 2));
  const childWords = toText(childHtml).toLowerCase().split(/\s+/).filter(w => w.length > 2);
  let newCount = 0;
  for (const w of childWords) { if (!parentWords.has(w)) newCount++; }
  return { size: newCount };
}

function extractNewConcepts(parentHtml, childHtml) {
  const concepts = [];
  const parentEl = document.createElement('div');
  parentEl.innerHTML = parentHtml;
  const childEl = document.createElement('div');
  childEl.innerHTML = childHtml;

  // New headings
  const parentHeadings = new Set([...parentEl.querySelectorAll('h1,h2,h3')].map(h => h.textContent.trim().toLowerCase()));
  for (const h of childEl.querySelectorAll('h1,h2,h3')) {
    const text = h.textContent.trim();
    if (text && !parentHeadings.has(text.toLowerCase())) concepts.push(text.substring(0, 60));
  }

  // New link texts
  const parentLinks = new Set([...parentEl.querySelectorAll('a')].map(a => a.textContent.trim().toLowerCase()));
  for (const a of childEl.querySelectorAll('a')) {
    const text = a.textContent.trim();
    if (text && text.length > 3 && !parentLinks.has(text.toLowerCase())) concepts.push(text.substring(0, 60));
  }

  // New bold/strong text
  const parentBold = new Set([...parentEl.querySelectorAll('strong,b')].map(b => b.textContent.trim().toLowerCase()));
  for (const b of childEl.querySelectorAll('strong,b')) {
    const text = b.textContent.trim();
    if (text && text.length > 3 && !parentBold.has(text.toLowerCase())) concepts.push(text.substring(0, 60));
  }

  return [...new Set(concepts)].slice(0, 8);
}

async function updateExplorationTree(url, title, feedKey, html, { parentFeedKey, explorationId, parentHtml }) {
  if (!state.firebaseReady || !firebaseDb || !feedKey) return;
  try {
    if (explorationId && parentFeedKey && parentHtml) {
      // Child navigation (link click) — extend existing tree
      const diffResult = computeContentDiff(parentHtml, html);
      const concepts = extractNewConcepts(parentHtml, html);

      // Find parent node by feedKey (client-side scan)
      const nodesSnap = await firebaseDb.ref('explorations/' + explorationId + '/nodes').once('value');
      let parentNodeId = null;
      if (nodesSnap.exists()) {
        nodesSnap.forEach(child => {
          if (child.val().feedKey === parentFeedKey) parentNodeId = child.key;
        });
      }

      const newNodeRef = firebaseDb.ref('explorations/' + explorationId + '/nodes').push();
      await newNodeRef.set({
        url: url.toLowerCase(),
        title: title,
        parentNodeId: parentNodeId,
        feedKey: feedKey,
        timestamp: Date.now(),
        diffSize: diffResult.size,
        concepts: concepts,
        tonalModifier: state.tonalModifier || null,
      });

      await firebaseDb.ref('feed/' + feedKey + '/explorationId').set(explorationId);
      state.currentExplorationId = explorationId;
    } else {
      // New root (user typed URL)
      const newExplorationRef = firebaseDb.ref('explorations').push();
      const newExplorationId = newExplorationRef.key;
      const newNodeRef = newExplorationRef.child('nodes').push();

      await newExplorationRef.set({
        rootUrl: url.toLowerCase(),
        authorUid: state.firebaseUid || null,
        author: state.displayName || 'Anonymous',
        createdAt: Date.now(),
        tonalModifier: state.tonalModifier || null,
        nodes: {
          [newNodeRef.key]: {
            url: url.toLowerCase(),
            title: title,
            parentNodeId: null,
            feedKey: feedKey,
            timestamp: Date.now(),
            diffSize: 0,
            concepts: [],
            tonalModifier: state.tonalModifier || null,
          }
        }
      });

      await firebaseDb.ref('feed/' + feedKey + '/explorationId').set(newExplorationId);
      state.currentExplorationId = newExplorationId;
    }
  } catch (err) {
    console.error('Exploration tree update failed:', err);
  }
}

let feedCache = { entries: null, at: 0 };
const FEED_CACHE_TTL = 60000; // 1 minute

async function loadFeed(bypassCache) {
  if (!state.firebaseReady || !firebaseDb) {
    feedList.innerHTML = `<div class="feed-empty">Community feed connecting...</div>`;
    setTimeout(() => { if (state.firebaseReady) loadFeed(); }, 1000);
    return;
  }
  // Serve from cache if fresh
  if (!bypassCache && feedCache.entries && (Date.now() - feedCache.at < FEED_CACHE_TTL)) {
    renderFeed(feedCache.entries);
    return;
  }
  feedList.innerHTML = '<div class="feed-empty">Loading...</div>';
  try {
    const snap = await firebaseDb.ref('feed')
      .orderByChild('timestamp')
      .limitToLast(50)
      .once('value');
    const entries = [];
    snap.forEach(child => {
      entries.push({ key: child.key, ...child.val() });
    });
    entries.reverse(); // newest first
    feedCache = { entries, at: Date.now() };
    renderFeed(entries);
  } catch (err) {
    feedList.innerHTML = `<div class="feed-empty">Error loading feed: ${escapeHtml(err.message)}</div>`;
  }
}

function renderFeed(entries) {
  if (entries.length === 0) {
    feedList.innerHTML = '<div class="feed-empty">No shared pages yet. Be the first to share!</div>';
    return;
  }

  let html = '';
  for (const entry of entries) {
    const title = escapeHtml(entry.title || entry.url);
    const url = escapeHtml(entry.url);
    const preview = escapeHtml(entry.preview || '');
    const author = escapeHtml(entry.author || 'Anonymous');
    const model = escapeHtml(entry.model || '?');
    const ago = timeAgo(entry.timestamp);
    const thumb = entry.screenshotUrl ? `<div class="feed-card-thumb"><img src="${escapeHtml(entry.screenshotUrl)}" alt="" loading="lazy" /></div>` : '';
    html += `
      <div class="feed-card" data-feed-key="${escapeHtml(entry.key)}" data-exploration-id="${escapeHtml(entry.explorationId || '')}">
        ${thumb}
        <div class="feed-card-title">${title}</div>
        <div class="feed-card-url">s/${url}</div>
        <div class="feed-card-preview">${preview}</div>
        <div class="feed-card-meta">
          <span><span class="feed-card-author">${author}</span> &middot; ${ago}</span>
          <span class="feed-card-model">${model}</span>
        </div>
        <div class="scrubber-bar" style="display:none"></div>
      </div>`;
  }

  feedList.innerHTML = html;

  // Bind card clicks — load the shared page
  feedList.querySelectorAll('.feed-card').forEach(card => {
    card.addEventListener('click', async () => {
      hideScrubberPopup();
      const key = card.dataset.feedKey;
      try {
        const snap = await firebaseDb.ref('feed/' + key).once('value');
        const entry = snap.val();
        if (entry && entry.html) {
          addressInput.value = entry.url;
          restorePage(entry.html);
          state.history = state.history.slice(0, state.historyIndex + 1);
          state.history.push({ url: entry.url, html: entry.html });
          state.historyIndex = state.history.length - 1;
          updateNavButtons();
          state.currentFeedKey = key;
          state.currentExplorationId = entry.explorationId || null;
          if (entry.explorationId && state.firebaseReady && firebaseDb) {
            firebaseDb.ref('explorations/' + entry.explorationId + '/tonalModifier').once('value')
              .then(snap => { state.tonalModifier = snap.val() || null; })
              .catch(() => {});
          }
          updateBrowserUrl(entry.url);
          $('#contentArea').scrollTop = 0;
        } else {
          navigateTo(entry.url);
        }
      } catch {
        // Fallback: just navigate
        const url = card.querySelector('.feed-card-url').textContent.replace(/^s\//, '');
        navigateTo(url);
      }
    });
  });
  bindScrubbers(feedList, entries);
}

function timeAgo(ts) {
  const diff = Date.now() - ts;
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'just now';
  if (mins < 60) return `${mins}m ago`;
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return `${hrs}h ago`;
  const days = Math.floor(hrs / 24);
  if (days < 7) return `${days}d ago`;
  return new Date(ts).toLocaleDateString([], { month: 'short', day: 'numeric' });
}

function toggleFeed(forceOpen) {
  const open = forceOpen !== undefined ? forceOpen : !feedPanel.classList.contains('open');
  feedPanel.classList.toggle('open', open);
  feedBackdrop.classList.toggle('open', open);
  if (open) loadFeed();
}

feedBtn.addEventListener('click', () => {
  const willClose = feedPanel.classList.contains('open');
  if (willClose) state.feedClosedByUser = true;
  else state.feedClosedByUser = false;
  toggleFeed();
});
closeFeedBtn.addEventListener('click', () => { state.feedClosedByUser = true; toggleFeed(false); });
feedBackdrop.addEventListener('click', () => { state.feedClosedByUser = true; toggleFeed(false); });
refreshFeedBtn.addEventListener('click', () => loadFeed(true));

// ── Welcome page feed (inline) ──
async function loadWelcomeFeed() {
  if (!welcomeFeedList) return;
  if (!state.firebaseReady || !firebaseDb) {
    welcomeFeedList.innerHTML = '<div class="feed-empty">Tuning in...</div>';
    return;
  }
  welcomeFeedList.innerHTML = '<div class="feed-empty">Scanning the airwaves...</div>';
  try {
    const snap = await firebaseDb.ref('feed')
      .orderByChild('timestamp')
      .limitToLast(30)
      .once('value');
    const entries = [];
    snap.forEach(child => {
      entries.push({ key: child.key, ...child.val() });
    });
    entries.reverse();
    // Deduplicate: show only the latest entry per version tree
    const seenExplorations = new Set();
    const seenUrls = []; // track URLs we've already accepted
    const deduped = entries.filter(e => {
      // Deduplicate by explorationId
      if (e.explorationId) {
        if (seenExplorations.has(e.explorationId)) return false;
        seenExplorations.add(e.explorationId);
      }
      // Deduplicate by URL lineage — skip if this URL is an ancestor/descendant of one already shown
      const url = (e.url || '').toLowerCase();
      if (url) {
        for (const prev of seenUrls) {
          if (url === prev || url.startsWith(prev + '/') || prev.startsWith(url + '/')) return false;
        }
        seenUrls.push(url);
      }
      return true;
    });
    renderWelcomeFeed(deduped, entries);
  } catch (err) {
    welcomeFeedList.innerHTML = `<div class="feed-empty">Could not load feed: ${escapeHtml(err.message)}</div>`;
  }
}

function renderWelcomeFeed(entries, allEntries) {
  if (!welcomeFeedList) return;
  if (entries.length === 0) {
    welcomeFeedList.innerHTML = '<div class="feed-empty">No pages yet. Generate something and it\'ll appear here!</div>';
    return;
  }
  let html = '';
  for (const entry of entries) {
    const title = escapeHtml(entry.title || entry.url);
    const url = escapeHtml(entry.url);
    const preview = escapeHtml(entry.preview || '');
    const author = escapeHtml(entry.author || 'Anonymous');
    const model = escapeHtml(entry.model || '?');
    const ago = timeAgo(entry.timestamp);
    const thumb = entry.screenshotUrl ? `<div class="feed-card-thumb"><img src="${escapeHtml(entry.screenshotUrl)}" alt="" loading="lazy" /></div>` : '';
    html += `
      <div class="feed-card" data-feed-key="${escapeHtml(entry.key)}" data-exploration-id="${escapeHtml(entry.explorationId || '')}">
        ${thumb}
        <div class="feed-card-title">${title}</div>
        <div class="feed-card-url">s/${url}</div>
        <div class="feed-card-preview">${preview}</div>
        <div class="feed-card-meta">
          <span><span class="feed-card-author">${author}</span> &middot; ${ago}</span>
          <span class="feed-card-model">${model}</span>
        </div>
        <div class="scrubber-bar" style="display:none"></div>
      </div>`;
  }
  welcomeFeedList.innerHTML = html;

  // Bind card clicks
  welcomeFeedList.querySelectorAll('.feed-card').forEach(card => {
    card.addEventListener('click', async () => {
      hideScrubberPopup();
      const key = card.dataset.feedKey;
      try {
        const snap = await firebaseDb.ref('feed/' + key).once('value');
        const entry = snap.val();
        if (entry && entry.html) {
          addressInput.value = entry.url;
          restorePage(entry.html);
          state.history = state.history.slice(0, state.historyIndex + 1);
          state.history.push({ url: entry.url, html: entry.html });
          state.historyIndex = state.history.length - 1;
          updateNavButtons();
          state.currentFeedKey = key;
          state.currentExplorationId = entry.explorationId || null;
          if (entry.explorationId && state.firebaseReady && firebaseDb) {
            firebaseDb.ref('explorations/' + entry.explorationId + '/tonalModifier').once('value')
              .then(snap => { state.tonalModifier = snap.val() || null; })
              .catch(() => {});
          }
          updateBrowserUrl(entry.url);
          if (!state.feedClosedByUser) toggleFeed(true);
          $('#contentArea').scrollTop = 0;
        } else {
          navigateTo(entry.url);
        }
      } catch {
        const url = card.querySelector('.feed-card-url').textContent.replace(/^s\//, '');
        navigateTo(url);
      }
    });
  });
  bindScrubbers(welcomeFeedList, allEntries || entries);
}

// ── Exploration Scrubber Controller ──
const scrubberCache = new Map();
let activeScrubberPopup = null;

function buildScrubber(card, treeData) {
  const bar = card.querySelector('.scrubber-bar');
  if (!bar) return;

  const nodeEntries = treeData.nodes
    ? Object.entries(treeData.nodes)
        .map(([id, n]) => ({ id, ...n }))
        .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0))
    : [];

  if (nodeEntries.length === 0) {
    nodeEntries.push({
      id: 'root', url: treeData.rootUrl || '?', title: '',
      parentNodeId: null, feedKey: null,
      timestamp: treeData.createdAt || 0, diffSize: 0, concepts: [],
    });
  }

  bar.innerHTML = '';
  bar.style.display = '';

  const fill = document.createElement('div');
  fill.className = 'scrubber-fill';
  bar.appendChild(fill);

  const popup = document.createElement('div');
  popup.className = 'scrubber-popup';
  popup.innerHTML = '<div class="scrubber-popup-thumb"></div><div class="scrubber-popup-title"></div><div class="scrubber-popup-url"></div><div class="scrubber-popup-concepts"></div><div class="scrubber-popup-diff"></div>';
  bar.appendChild(popup);

  const dots = [];
  for (let i = 0; i < nodeEntries.length; i++) {
    const node = nodeEntries[i];
    const pct = nodeEntries.length === 1 ? 50 : (i / (nodeEntries.length - 1)) * 100;
    const dot = document.createElement('div');
    dot.className = 'scrubber-dot' + (!node.parentNodeId ? ' root' : '');
    dot.style.left = pct + '%';
    bar.appendChild(dot);
    dots.push({ el: dot, node, pct });
  }

  bar._scrubberData = { dots, popup, fill, nodes: nodeEntries };
}

function handleScrubberMove(bar, clientX) {
  const data = bar._scrubberData;
  if (!data) return;

  const rect = bar.getBoundingClientRect();
  const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  const pctMouse = ratio * 100;

  let nearest = data.dots[0];
  let minDist = Infinity;
  for (const d of data.dots) {
    const dist = Math.abs(d.pct - pctMouse);
    if (dist < minDist) { minDist = dist; nearest = d; }
  }

  for (const d of data.dots) d.el.classList.toggle('active', d === nearest);
  data.fill.style.width = nearest.pct + '%';

  const popup = data.popup;
  const node = nearest.node;

  // Horizontal clamp so popup doesn't overflow card edges
  const barWidth = rect.width;
  const popupWidth = 160;
  const dotPx = (nearest.pct / 100) * barWidth;
  const halfPopup = popupWidth / 2;
  if (dotPx < halfPopup) {
    popup.style.transform = 'translateX(0)';
    popup.style.left = '0';
  } else if (dotPx > barWidth - halfPopup) {
    popup.style.transform = 'translateX(-100%)';
    popup.style.left = '100%';
  } else {
    popup.style.transform = 'translateX(-50%)';
    popup.style.left = nearest.pct + '%';
  }

  popup.querySelector('.scrubber-popup-title').textContent = node.title || node.url || '?';

  const urlEl = popup.querySelector('.scrubber-popup-url');
  if (node.url) {
    urlEl.textContent = 's/' + (node.url.length > 38 ? node.url.substring(0, 35) + '...' : node.url);
    urlEl.style.display = '';
  } else {
    urlEl.style.display = 'none';
  }

  const conceptsEl = popup.querySelector('.scrubber-popup-concepts');
  if (node.concepts && node.concepts.length > 0) {
    conceptsEl.innerHTML = node.concepts.map(c => `<span class="scrubber-concept-tag">${escapeHtml(c)}</span>`).join('');
    conceptsEl.style.display = '';
  } else {
    conceptsEl.style.display = 'none';
  }

  const diffEl = popup.querySelector('.scrubber-popup-diff');
  if (node.diffSize > 0) {
    diffEl.innerHTML = '<span class="diff-count">+' + node.diffSize + '</span> new words';
    diffEl.style.display = '';
  } else if (!node.parentNodeId) {
    diffEl.innerHTML = 'origin';
    diffEl.style.display = '';
  } else {
    diffEl.style.display = 'none';
  }

  const thumbEl = popup.querySelector('.scrubber-popup-thumb');
  if (node.screenshotUrl) {
    thumbEl.style.display = '';
    const existing = thumbEl.querySelector('img');
    if (!existing || existing.src !== node.screenshotUrl) {
      thumbEl.innerHTML = '<img src="' + escapeHtml(node.screenshotUrl) + '" alt="" />';
    }
  } else {
    thumbEl.style.display = 'none';
    thumbEl.innerHTML = '';
  }

  popup.classList.add('visible');
  activeScrubberPopup = popup;
}

function handleScrubberClick(bar, clientX) {
  const data = bar._scrubberData;
  if (!data) return;

  const rect = bar.getBoundingClientRect();
  const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  const pctMouse = ratio * 100;

  let nearest = data.dots[0];
  let minDist = Infinity;
  for (const d of data.dots) {
    const dist = Math.abs(d.pct - pctMouse);
    if (dist < minDist) { minDist = dist; nearest = d; }
  }

  const node = nearest.node;
  if (node.feedKey) loadFeedEntry(node.feedKey);
}

async function loadFeedEntry(feedKey) {
  if (!state.firebaseReady || !firebaseDb) return;
  try {
    const snap = await firebaseDb.ref('feed/' + feedKey).once('value');
    const entry = snap.val();
    if (entry && entry.html) {
      addressInput.value = entry.url;
      restorePage(entry.html);
      state.history = state.history.slice(0, state.historyIndex + 1);
      state.history.push({ url: entry.url, html: entry.html });
      state.historyIndex = state.history.length - 1;
      updateNavButtons();
      state.currentFeedKey = feedKey;
      state.currentExplorationId = entry.explorationId || null;
      updateBrowserUrl(entry.url);
      $('#contentArea').scrollTop = 0;
    } else if (entry) {
      navigateTo(entry.url);
    }
  } catch { /* silent */ }
}

function hideScrubberPopup() {
  if (activeScrubberPopup) {
    activeScrubberPopup.classList.remove('visible');
    activeScrubberPopup = null;
  }
}

function fetchAndBuildScrubber(card, allEntries) {
  const explorationId = card.dataset.explorationId;
  const cardUrl = (card.querySelector('.feed-card-url')?.textContent || '').replace(/^s\//, '').toLowerCase();
  if (!cardUrl) return;

  const cacheKey = explorationId || 'url:' + cardUrl;
  const cached = scrubberCache.get(cacheKey);
  if (cached && (Date.now() - cached.at < 300000)) {
    buildScrubber(card, cached.data);
    return;
  }

  // Build tree from all feed entries that share this URL lineage
  // A feed entry is related if its URL is a prefix of ours, or ours is a prefix of it
  const related = allEntries.filter(e => {
    const eUrl = (e.url || '').toLowerCase();
    if (!eUrl) return false;
    return eUrl === cardUrl || cardUrl.startsWith(eUrl + '/') || eUrl.startsWith(cardUrl + '/');
  }).sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

  // Also include entries sharing the same explorationId
  if (explorationId) {
    for (const e of allEntries) {
      if (e.explorationId === explorationId && !related.find(r => r.key === e.key)) {
        related.push(e);
      }
    }
    related.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  }

  if (related.length <= 1) {
    // Only this single entry — try Firebase exploration as fallback
    if (explorationId && state.firebaseReady && firebaseDb) {
      firebaseDb.ref('explorations/' + explorationId).once('value')
        .then(snap => {
          const data = snap.val();
          if (data && data.nodes && Object.keys(data.nodes).length > 1) {
            scrubberCache.set(cacheKey, { data, at: Date.now() });
            buildScrubber(card, data);
          }
        })
        .catch(() => {});
    }
    return;
  }

  // Build a virtual exploration tree from feed entries
  const nodes = {};
  for (const entry of related) {
    const nodeId = entry.key;
    const entryUrl = (entry.url || '').toLowerCase();
    // Find parent: the longest URL that is a prefix of this entry's URL
    let parentNodeId = null;
    let longestPrefix = 0;
    for (const other of related) {
      if (other.key === entry.key) continue;
      const otherUrl = (other.url || '').toLowerCase();
      if (entryUrl.startsWith(otherUrl + '/') && otherUrl.length > longestPrefix) {
        longestPrefix = otherUrl.length;
        parentNodeId = other.key;
      }
    }
    nodes[nodeId] = {
      url: entryUrl,
      title: entry.title || entryUrl,
      parentNodeId: parentNodeId,
      feedKey: entry.key,
      timestamp: entry.timestamp || 0,
      diffSize: 0,
      concepts: [],
    };
  }

  const treeData = { rootUrl: related[0].url, nodes };
  scrubberCache.set(cacheKey, { data: treeData, at: Date.now() });
  buildScrubber(card, treeData);
}

function bindScrubbers(container, entries) {
  container.querySelectorAll('.feed-card').forEach(card => {
    fetchAndBuildScrubber(card, entries || []);

    const bar = card.querySelector('.scrubber-bar');
    if (!bar) return;

    bar.addEventListener('mousemove', (e) => {
      e.stopPropagation();
      handleScrubberMove(bar, e.clientX);
    });

    bar.addEventListener('mouseleave', () => {
      hideScrubberPopup();
      if (bar._scrubberData) {
        for (const d of bar._scrubberData.dots) d.el.classList.remove('active');
        bar._scrubberData.fill.style.width = '0';
      }
    });

    bar.addEventListener('click', (e) => {
      e.stopPropagation();
      handleScrubberClick(bar, e.clientX);
    });
  });
}

// ── Utils ──
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}
</script>
</body>
</html>
